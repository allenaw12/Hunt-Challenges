<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huntober Challenge Week 2: Arrays!!!</title>
</head>
<body  style="background-color: black; color: orange;  line-height: 25px;">
<h1>Week 2 - Arrays!</h1>
<p>Hey everybody! Welcome to the first day of my second week of daily web dev challenges this October ðŸŽƒ.
    This week our challenges all deal with Arrays! Their purpose is to store a collection of things under a single reference name, but the way they are set up and used in JavaScript is a little different from other programming languages. If you're coming from a different language, be sure to check out what's different! While working on our challenges, feel free to use JavaScript's built-in Array methods.</p>
<h2>Day 1</h2>
    <p>This week we'll be working with arrays toward a final puzzling result on Friday when we combine our daily functions. Your solutions should be built to work within any given daily constraints.
        Do you know how to compare arrays? Not sure? Don't worry, you'll figure it out...
        Today's task is to write a function that will check equality between 2 arrays with a particular structure.
        The arrays will:
        Be of equal size
        Will each contain some number (X) arrays
        Each inner array will contain that same number (X) primitive elements
        All the nested primitives within each array must strictly match to return a true result. Any mismatches will return false.
        For example:
    <pre>// each of these arrays have 3 nested arrays of 3 strings each 
        const arr1 = [['a','b','c'],['d','e','f'],['g','h','i']]
        const arr2 = [['a','b','c'],['d','e','f'],['g','h','i']]
        const arr3 = [['a','B','c'],['d','E','f'],['g','H','i']]
        const arr4 = [['a','b','c'],['g','h','i'],['d','e','f']]
        // if we were to use our function to compare all the possible pairs
        // ONLY arr1 vs arr2 would return true
        checkEquality(arr1, arr2) => true
        checkEquality(arr1, arr3) => false
        checkEquality(arr1, arr4) => false
        // etc.</pre>
        Good luck! Check back tomorrow for the next challenge of the week!</p>
<h2>Day 2</h2>
    <p>So it turns out that some of the information I stored ever-so-safely in arrays just isn't looking right. I'm not going to be happy until it feels right, you know what I mean? Could you help me rearrange things a bit?
        I need twin functions, a function that swaps a given primitive value in a given 1-dimensional array to an index to the left, and another that swaps it to the right.
        Some things to note:
        If the given value is on the edge of the array and can't move in that direction, don't move it.
        The given primitive value will only occur once in the array
        The array passed in should be mutated by this function. Scandalous, I know.
        Example:
    <pre>myArray = ['abc', 'xyz', 1, 2, 'Hey!']

        // call move left function with 'xyz' and myArray as arguments
        console.log(myArray)   // ['xyz', 'abc', 1, 2, 'Hey!']
        
        // call move left function again, same arguments
        // Note that 'xyz' is already as far left as it can go
        console.log(myArray) // ['xyz', 'abc', 1, 2, 'Hey!'] no change
        
        // call move right function this time, with 2 and myArray as arguments
        console.log(myArray) // ['xyz', 'abc', 1, 'Hey!', 2]
        
        // call move right function again, same arguments
        // Note that 2 is already as far right as it can go
        console.log(myArray) // ['xyz', 'abc', 1, 'Hey!', 2] no change
        </pre>
        Got it? Great! I can't wait to get moving things around.
    </p>
<h2>Day 3</h2>
    <p>Today's challenge is a bit of a tangent, but I think it's pretty powerful. It's inspired by my favorite Codewars kata ever, Moving Zeros To The End. This is my favorite kata because the first time I did it, my approach was so convoluted compared to the top-voted solution, which was a thing of beautiful simplicity. I think the moment I saw that solution something clicked for me and I realized the power of the built-in Javascript methods.
        Today I'd like you to write a function that:
        takes in a given array of strings and move any entries containing the letter 'a' to the front
        then move any remaining entries that have over 3 characters to the back
        please preserve the relative order of entries within their given category
        Example:
        <pre>myArr = ['hi', 'hello', 'howdy', 'hola', 'hej', 'hallo', 'heyyy']
        // move things around
        => ['hola', 'hallo', 'hi', 'hej', 'hello', 'howdy', 'heyyy']
        </pre>
    Have fun!</p>
<h2>Day 4</h2>
    <p></p>
<script>
    //Day 1
//create a function that compares arrays of arrays, if every value is the same, return true, otherwise return false
//parameters take in 2 arrays with a certain number of subarrays. the number of subarrays will always be equal. will they ever empty?
function checkEquality(arr1, arr2){
    //loop thru arr1 and compare to same index as arr2
    //if not same, break loop return false
    //otherwise return true
    return arr1.every((subArr, i) => subArr.every((el, j) => arr2[i][j] === el))
}
//returns boolean true false  whether all input arrays and subarrays match or not
const arr1 = [['a','b','c'],['d','e','f'],['g','h','i']]
const arr2 = [['a','b','c'],['d','e','f'],['g','h','i']]
const arr3 = [['a','B','c'],['d','E','f'],['g','H','i']]
const arr4 = [['a','b','c'],['g','h','i'],['d','e','f']]
console.log(checkEquality(arr1, arr2), 'true')
console.log(checkEquality(arr1, arr3), 'false')
console.log(checkEquality(arr1, arr4), 'false')

    //Day 2
//2 functions, one to move a given value one index to the left, and another to move a given value one index to the right
//if that value can't move anymore to left or right respectively it shouldn't move
//input array should be mutated
//parameters of functions moveOneLeft and moveOneRight are: a value, could be a string or number of varying lengths, will it ever be empty or nonexistant? it will always only occur once in given array. parameter 2 is an array of varying values, can it ever be empty?
function moveOneLeft(arr, val){
    //find index of given value
    //if it's 0, return arr as is
    //otherwise, splice at index of val, delete 1, then splice value back in at index -1 than original
    //return array
    let i = arr.indexOf(val)
    if(i <= 0){
        return arr
    }else{
        let move = arr.splice(i, 1)
        arr.splice(i-1, 0, move[0])
        return arr
    }    
}
//returns original array with val moved one index to the left, or not changed in index
function moveOneRight(arr, val){
    //get index of val in arr
    //if it's length of arr -1, return arr
    //otherwise, splice arr at index of val and delete val, then splice it back in at index +1
    //return array
    let i = arr.indexOf(val)
    if(i >= arr.length-1){
        return arr
    }else{
        let move = arr.splice(i, 1)
        arr.splice(i+1, 0, move[0])
        return arr
    }
}
//returns original array with val moved one index to the right, or not changed in index
let myArray = ['abc', 'xyz', 1, 2, 'Hey!']
console.log(moveOneLeft(myArray, 'xyz'), "['xyz', 'abc', 1, 2, 'Hey!']")
console.log(moveOneLeft(myArray, 'xyz'), "['xyz', 'abc', 1, 2, 'Hey!']")
console.log(moveOneRight(myArray, 2),"['xyz', 'abc', 1, 'Hey!', 2]")
console.log(moveOneRight(myArray, 2),"['xyz', 'abc', 1, 'Hey!', 2]")

    //Day 3
//a function takes in an array of strings. can it ever be empty? can there be other value types within it besides strings?
//need to do 3 things to given array before returning it: all words with a in them are moved to front of array(keep order they were originally in in array), all words with over 3 characters are moved to end of array (keep order they were originally in in array), preserve relative order of entries within given category
//parameter takes in an array of string
function moveStringsAround(arr){
    //want to make a copy to mutate
    //declare 3 variables, to hold a's, 3+, and rest
    //loop thru and if string includes 'a', push to a
    //if string length is over 3, push to 3+
    //otherwise push to rest
    //return concat of 3 arrays, using concat
    let allA = [],
    threePlus = [],
    others = []
    arr.forEach(el => {
        if(el.includes('a')){
            allA.push(el)
        }else if(el.length > 3){
            threePlus.push(el)
        }else{
            others.push(el)
        }
    })
    return allA.concat(others, threePlus)
}
//return array with rearranged values, can i mutate original array? or should I make a copy?
let myArr = ['hi', 'hello', 'howdy', 'hola', 'hej', 'hallo', 'heyyy']
console.log(moveStringsAround(myArr), "'hola', 'hallo', 'hi', 'hej', 'hello', 'howdy', 'heyyy'")

</script>
</body>
</html>